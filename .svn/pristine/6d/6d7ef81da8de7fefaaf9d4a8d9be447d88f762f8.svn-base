
import { BaseCell } from '../../module/cell/baseCell';
import { ContainerInterface } from '../../interface/ContainerInterface';
import * as _ from '../../utils';
import { BaseTable } from '../table/baseTable';
// 只有对于容器来说才有相对位置
export class Container implements ContainerInterface {
    public EPI_READY = true; // 是否可以快速导出和恢复
    public config = {
        editStatus: true,
        baseSide1: 100,
        baseSide2: 28,
    };
    public name: string;
    public $root: BaseTable; // 根容器
    public showType: number = 0;
    public selected: boolean = false;
    public cell: BaseCell | null = null; // 容器内填充Cell

    public side1: number; // 横表头 为width 纵表头为height
    public side2: number; // 纵表头 为width 横表头为height
    public side1Value: number = 100;

    public style: any = {
        width: '100px',
        height: '28px',
        lineHeight: '28px',
        overflow: 'hidden',
        minWidth: '10px',
        boxSizing: 'border-box',
        whiteSpace: 'nowrap',
        textOverflow: 'ellipsis',
    };
    constructor(name?: string, side1?: number, side2?: number, root?: any) {
        this.name = name || '';
        this.$root = root;
        this.side1 = side1 == null ? 1 : side1;
        this.side2 = side2 == null ? 1 : side2;
        if (root) {
            const defaultConfig = root.defaultConfig.container;
            this.setConfig(defaultConfig);
        }
    }

    /**
     * changeShowType
     */
    public changeShowType(type: number) {
        if (this.config.editStatus) {
            this.showType = type;
        }
    }

    /**
     * setConfig
     */
    public setConfig(config: any) {
        try {
            for (const key in this.config) {
                if (config && config.hasOwnProperty(key)) {
                    (this.config as any)[key] = _.clone(config[key]);
                }
            }
            switch (this.name) {
                case 'top':
                    this.config.baseSide1 = config.baseSide1;
                    this.config.baseSide2 = config.baseSide2;
                    break;
                case 'left':
                    this.config.baseSide1 = config.baseSide2;
                    this.config.baseSide2 = config.baseSide1;
                    break;
                default:
                    this.config.baseSide1 = config.baseSide1;
                    this.config.baseSide2 = config.baseSide2;
            }
        } catch (error) {
            console.error('Container error');
        }
    }

    public setCell(cell: BaseCell) {
        this.cell = cell;
    }
    public setProperty(key: string, val: any) {
        (this as any)[key] = val;
    }

    public onClick(event: any) {
        console.log('click');
    }

    /**
     * clone
     */
    public clone(exclude?: string[], withFunction?: boolean) {
        const object: any = {};
        for (const key in this) {
            if (this.hasOwnProperty(key) || (withFunction && typeof this[key] === 'function')) {
                let val: any = null;
                let needContinue = false;
                if (exclude) {
                    exclude.forEach((keyWord) => {
                        if (key.indexOf(keyWord) !== -1) {
                            needContinue = true;
                        }
                    });
                }
                if (needContinue) {
                    continue;
                } else if (Array.isArray(this[key])) {
                    val = [];

                    (this[key] as any).forEach((item: any) => {

                        if (item.EPI_READY && typeof item.clone === 'function') {
                            val.push(item.clone(exclude));
                        } else {
                            val.push(item);
                        }
                    });
                    // val = Array.from(this[key] as any);
                } else {
                    val = this[key];
                }
                object[key] = _.clone(val);
            }
        }
        return object;
    }
}

