import { TheadContainer } from '../container/TheadContainer';
import { Subject } from '../../communication/Subject';
import { DragTsData, ContainerBearing } from '../../interface/DragTsData';
import { DragStartData } from '../../interface/DragStartData';
import { BaseStyle } from '../style/Style';
import { TheadContainerInterface } from '../../interface/TheadContainerInterface';
import { BaseCell } from '../../module/cell/baseCell';
import * as _ from '../../utils/index';

export class BaseThead extends TheadContainer {

    public leafIndexList: any[] = []; // 叶子节点顺序列表
    public dragStartData: any = null;
    //  表头变化
    private theadSubject = new Subject();
    
    constructor(name?: any, root?: any) {
        super(name, 0, 0, root);
    }

    public theadChange(msg?: DragTsData) {
        this.theadSubject.sendMsg(msg);
    }


    public initThead(type: string, data: any[]) {
        for (let i = 0; i < (data || []).length; i++) {
            const tmpContainer  = new TheadContainer(type, 1, 1);
            tmpContainer.setCell(new BaseCell(data[i], 1, 1));
            this.addChild(tmpContainer);
        }
    }

    /**
     * 通用dragStart
     *
     * @param {*} ev
     * @param {Container} target
     * @memberof BaseThead
     */
    public dragStart(ev: any, dragStartData: DragStartData) {
        this.dragStartData = dragStartData;
        ev.dataTransfer.setData('dragStartData', JSON.stringify(dragStartData));
    }


    /**
     * 通用dragover
     *
     * @param {*} ev
     * @param {target} th 
     * @memberof BaseThead
     */
    public dragOver(ev: any, th: TheadContainer) {
        const targetDom = BaseStyle.getParentTHTD(ev.target);
        this.resetDragOverStyle(targetDom);
        if (th.positionCheck) {
            const bearing = BaseStyle.checkBearing(ev);
            BaseStyle.addBorder(targetDom, bearing, 3, '#000');
            if (bearing === ContainerBearing.INNER) {
                BaseStyle.addBackgroundColor(targetDom, 'red');
            }

        }
        ev.preventDefault();
    }

    public dragLeave(ev: any) {
        const targetDom = BaseStyle.getParentTHTD(ev.target);
        this.resetDragOverStyle(targetDom);
    }
    /**
     * 横表专用drop
     *
     * @param {*} ev
     * @param {Container} item
     * @memberof BaseThead
     */
    public drop(ev: any, th: TheadContainer) {
        const stringData = ev.dataTransfer.getData('dragStartData');
        let dragStartData: any;
        if (stringData) {
            dragStartData = JSON.parse(ev.dataTransfer.getData('dragStartData'));
        }
        let dragTsData;
        if (th.positionCheck) {
            const bear: ContainerBearing = BaseStyle.checkBearing(ev);
            const target = this.getContainer(th.position);
            dragTsData = new DragTsData(this.name, target, bear, (dragStartData || null));
        } else {
            dragTsData = new DragTsData(this.name, this, ContainerBearing.OTHER, (dragStartData || null));
        }
        const targetDom = BaseStyle.getParentTHTD(ev.target);
        this.resetDragOverStyle(targetDom);
        this.theadChange(dragTsData);
    }

    /**
     * 拖拽删除函数
     *
     * @param {TheadContainer} th
     * @memberof BaseThead
     */
    public dragDel(th: TheadContainer) {
        const parentContainer = this.getParentConatiner(th.position);
        parentContainer.deletChild(_.last(th.position), 1, true);
        this.theadChange();
    }


    /**
     * getContainer
     * 备注：获得子容器
     * @param position: Position 相对于根容器的位置
     *
     */
    public getContainer(position: number[]) {
        let res: any = this;
        (position || []).forEach((index: number) => {
            res = res.children[index];
        });
        return res;
    }

    /**
     * getContainer
     * 备注：容器转换横表
     * @param position: Position 相对于根容器的位置
     *
     */
    public convert2TheadTopList() {
        this.leafIndexList = [];
        this.resize(); // this.resize(this.leafIndexList); 如果list需要是源container 解除注释
        const list: any[] = [];
        for (let i = 0; i < this.side2; i++) {
            list.push([]);
        }
        this.children.forEach((child: TheadContainer) => {
            child.getTopList(list, this.leafIndexList);
        });
        return list;
    }
    // 转换成纵表
    public convert2TheadLeftList() {
        this.resize(this.leafIndexList);
        let list: any[] = [];
        this.children.forEach((child, i) => {
            if (i === 0) {
                list.push([]);
            }
            let tmpList = child.getLeftList(list);
            if (JSON.stringify(tmpList) === '[[]]') {
                tmpList = [];
            }
            list = list.concat(tmpList);
        });
        this.leafIndexList = [];
        for (let i = 0; i < list.length; i++) {
            const tr = list[i];
            if (tr.length === this.side2) {
                this.leafIndexList = tr;
                break;
            }
        }
        return list;
    }

    public addParent(sourceContainerList: any[]) {
        const parentContainer: TheadContainer = this.getContainer(_.dropRight(sourceContainerList[0].position, 1));
        const tmpContainer = this.createContain({
            containerData: {
                cell: {
                    content: '新建合计',
                    data: '',
                },
                showType: 0,
            },
        } as DragStartData);
        sourceContainerList.forEach((th: TheadContainer) => {
            parentContainer.deletChild(_.last(th.position), 1, true);
        });
        parentContainer.addChild(tmpContainer, _.last(_.last(sourceContainerList).position));
        tmpContainer.children = sourceContainerList;
        this.theadChange();
    }


    /**
     * merge
     */
    public merge(targetContainerCopy: TheadContainerInterface) {
        const targetContainer = this.getContainer(targetContainerCopy.position || []);
        targetContainer.mergeList = targetContainerCopy.mergeList;
        targetContainer.mergeList.forEach((th: TheadContainer) => {
            if (targetContainer.cell && th.cell) {
                // targetContainer.cell.span1 += th.cell.span1;
                // targetContainer.cell.span2 += th.cell.span2;
                const sourceContainer = this.getContainer(th.position);
                sourceContainer.style.display = 'none';
            }
        });
    }

    /**
     * disMerge
     */
    public disMerge(targetContainerCopy: TheadContainerInterface) {
        const targetContainer = this.getContainer(targetContainerCopy.position || []);
        targetContainer.mergeList = targetContainerCopy.mergeList;
        targetContainer.mergeList.forEach((th: TheadContainer) => {
            if (targetContainer.cell && th.cell) {
                // targetContainer.cell.span1 -= th.cell.span1;
                // targetContainer.cell.span2 -= th.cell.span2;
                const sourceContainer = this.getContainer(th.position);
                sourceContainer.style.display = 'table-cell';
            }
        });
    }

    private getParentConatiner(positon: number[]): TheadContainer {
        const parentPostion = _.dropRight(positon, 1);
        return this.getContainer(parentPostion);
    }

    private resetDragOverStyle(targetDom: any) {
        BaseStyle.removeBorder(targetDom);
        BaseStyle.removeBackgroundColor(targetDom);
    }

}